# Проектная работа 5-го спринта по DWH для нескольких источников

В рамках проекта вам предстоит усовершенствовать ваше хранилище: добавить новый источник и витрину. При этом данные из нового источника необходимо связать с данными, которые уже лежат в хранилище.

Данные, которые уже лежат в хранилище, — это те данные, которые вы собрали в спринте. Не останавливайте созданные DAG: они должны продолжать работу и докачивать новые данные. Если вы уже остановили, запустите их снова. Результат их работы вам понадобится.

## Задача проекта

Ваша конечная задача — реализовать витрину для расчётов с курьерами. В ней вам необходимо рассчитать суммы оплаты каждому курьеру за предыдущий месяц. Например, в июне выплачиваем сумму за май. Расчётным числом является 10-е число каждого месяца (это не повлияет на вашу работу). Из витрины бизнес будет брать нужные данные в готовом виде.

Для этого вам нужно создать многослойный DWH и реализовать ETL-процессы, которые будут преобразовывать и перемещать данные от источников до конечных слоёв данных.

Необходимо:

-   Изучить возможные источники и их внутреннюю модель хранения данных, а также технологии, которые используются для получения данных из этих источников.
-   На основе требований, целей дальнейшего использования, информации об источниках нужно спроектировать многослойную модель DWH, подробно прорабатывая каждый слой данных.
-   Для передачи результатов заказчику оформить всю необходимую документацию.

## Описание задачи

Вам необходимо построить витрину, содержащую информацию о выплатах курьерам.

Состав витрины:

-   `id` — идентификатор записи.
-   `courier_id` — ID курьера, которому перечисляем.
-   `courier_name` — Ф. И. О. курьера.
-   `settlement_year` — год отчёта.
-   `settlement_month` — месяц отчёта, где `1` — январь и `12` — декабрь.
-   `orders_count` — количество заказов за период (месяц).
-   `orders_total_sum` — общая стоимость заказов.
-   `rate_avg` — средний рейтинг курьера по оценкам пользователей.
-   `order_processing_fee` — сумма, удержанная компанией за обработку заказов, которая высчитывается как `orders_total_sum * 0.25`.
-   `courier_order_sum` — сумма, которую необходимо перечислить курьеру за доставленные им/ей заказы. За каждый доставленный заказ курьер должен получить некоторую сумму в зависимости от рейтинга (см. ниже).
-   `courier_tips_sum` — сумма, которую пользователи оставили курьеру в качестве чаевых.
-   `courier_reward_sum` — сумма, которую необходимо перечислить курьеру. Вычисляется как `courier_order_sum + courier_tips_sum * 0.95` (5% — комиссия за обработку платежа).

Правила расчёта процента выплаты курьеру в зависимости от рейтинга, где r — это средний рейтинг курьера в расчётном месяце:

-   r < 4 — 5% от заказа, но не менее 100 р.;
-   4 <= r < 4.5 — 7% от заказа, но не менее 150 р.;
-   4.5 <= r < 4.9 — 8% от заказа, но не менее 175 р.;
-   4.9 <= r — 10% от заказа, но не менее 200 р.

Данные о заказах уже есть в хранилище. Данные курьерской службы вам необходимо забрать из API курьерской службы, после чего совместить их с данными подсистемы заказов.

Отчёт собирается по дате заказа. Если заказ был сделан ночью и даты заказа и доставки не совпадают, в отчёте стоит ориентироваться на дату заказа, а не дату доставки. Иногда заказы, сделанные ночью до 23:59, доставляют на следующий день: дата заказа и доставки не совпадёт. Это важно, потому что такие случаи могут выпадать в том числе и на последний день месяца. Тогда начисление курьеру относите к дате заказа, а не доставки.

## Инструкция по выполнению проекта

#### **1. Изучите API системы доставки заказов**

#### **Спецификация API**

**GET /restaurants**

Метод `/restaurants` возвращает список доступных ресторанов (`_id`, `name`). В заголовке запроса нужно указать:

-   `X-Nickname` — ваш никнейм (например, sashanikonov);
-   `X-Cohort` со значением номера вашей когорты (например, 1);
-   `X-API-KEY` со значением `xxx`. Если не указать верный ключ к API, то вместо ожидаемого результата выйдет ошибка доступа.

Установите предварительно утилиту curl, чтобы с помощью неё обратиться к API. Выполните следующие команды в командной строке:

Скопировать кодJSX

```
curl --location --request GET 'https://d5d04q7d963eapoepsqr.apigw.yandexcloud.net/restaurants?sort_field={{ sort_field }}&sort_direction={{ sort_direction }}&limit={{ limit }}&offset={{ offset }}' \
--header 'X-Nickname: {{ your_nickname }}' \
--header 'X-Cohort: {{ your_cohort_number }}' \
--header 'X-API-KEY: {{ api_key }}' 
```

В качестве переменных заголовка, указанных в `{{ }}`, передайте ваши актуальные данные.

Описание параметров запроса, указанных в `{{ }}` :

-   `sort_field` — необязательный параметр. Возможные значения: `id`, `name`. Значение по умолчанию: `id`.  
    Параметр определяет поле, к которому будет применяться сортировка, переданная в параметре `sort_direction`.
-   `sort_direction` — необязательный параметр. Возможные значения: `asc`, `desc`.  
    Параметр определяет порядок сортировки для поля, переданного в `sort_field`:  
    -   `asc` — сортировка по возрастанию,
    -   `desc` — сортировка по убыванию.
-   `limit` — необязательный параметр. Значение по умолчанию: `50`. Возможные значения: целое число в интервале от `0` до `50` включительно.  
    Параметр определяет максимальное количество записей, которые будут возвращены в ответе.
-   `offset` — необязательный параметр. Значение по умолчанию: `0`.  
    Параметр определяет количество возвращаемых элементов результирующей выборки, когда формируется ответ.

Метод возвращает список ресторанов. Каждый ресторан списка содержит:

-   `_id` — ID задачи;
-   `name` — название ресторана.

**GET /couriers**

Метод `/couriers` используется для того, чтобы получить список курьеров с учётом фильтров, переданных в запросе.

С помощью утилиты curl обратитесь к API:

Скопировать кодJSX

```
curl --location --request GET 'https://d5d04q7d963eapoepsqr.apigw.yandexcloud.net/couriers?sort_field={{ sort_field }}&sort_direction={{ sort_direction }}&limit={{ limit }}&offset={{ offset }}' \
--header 'X-Nickname: {{ your_nickname }}' \
--header 'X-Cohort: {{ your_cohort_number }}' \
--header 'X-API-KEY: {{ api_key }}' 
```

Параметры `/couriers` аналогичны параметрам в предыдущем методе: `sort_field`, `sort_direction`, `limit`, `offset`.

Метод возвращает список курьеров. Каждый элемент списка содержит:

-   `_id` — ID курьера в БД;
-   `name` — имя курьера.

**GET / deliveries**

Метод `/deliveries` используется для того, чтобы получить список совершённых доставок с учётом фильтров, переданных в запросе.

С помощью утилиты curl обратитесь к API:

Скопировать кодJSX

```
curl --location --request GET 'https://d5d04q7d963eapoepsqr.apigw.yandexcloud.net/deliveries?restaurant_id={{ restaurant_id }}&from={{ from }}&to={{ to }}&sort_field={{ sort_field }}&sort_direction={{ sort_direction }}&limit={{ limit }}&offset={{ limit }}' \
--header 'X-Nickname: {{ your_nickname }}' \
--header 'X-Cohort: {{ your_cohort_number }}' \
--header 'X-API-KEY: {{ api_key }}' 
```

Параметры метода также включают `sort_direction`, `limit`, `offset` и несколько дополнительных полей:

-   `sort_field` — необязательный параметр. Возможные значения: `_id`, `date`. Если указать `_id`, то будет применена сортировка по ID заказа (`order_id`). Если указать date, то будет применена сортировка по дате создания заказа (`order_ts`).
-   `restaurant_id` — ID ресторана. Если значение не указано, то метод вернёт данные по всем доступным в БД ресторанам.
-   `from` — параметр фильтрации. В выборку попадают заказы с датой доставки, которая больше или равна значению `from`. Дата должна быть в формате `'%Y-%m-%d %H:%M:%S’`, например, `2022-01-01 00:00:00`.
-   `to` — параметр фильтрации. В выборку попадают заказы с датой доставки меньше значения `to`.

Метод возвращает список совершённых доставок с учётом фильтров в запросе. Каждый элемент списка содержит:

-   `order_id` — ID заказа;
-   `order_ts` — дата и время создания заказа;
-   `delivery_id` — ID доставки;
-   `courier_id` — ID курьера;
-   `address` — адрес доставки;
-   `delivery_ts` — дата и время совершения доставки;
-   `rate` — рейтинг доставки, который выставляет покупатель: целочисленное значение от 1 до 5;
-   `sum` — сумма заказа (в руб.);
-   `tip_sum` — сумма чаевых, которые оставил покупатель курьеру (в руб.).

#### **2. Создайте таблицы для слоёв в хранилище**

Вы знаете, какие данные нужны, чтобы построить витрину. Часть этой информации уже есть в хранилище данных, часть надо будет загрузить из API.

Для начала займитесь проектированием. Подумайте и опишите в файле `api_entities.md` следующее:

1.  Список полей, которые необходимы для витрины.
2.  Список таблиц в слое DDS, из которых вы возьмёте поля для витрины. Отметьте, какие таблицы уже есть в хранилище, а каких пока нет. Недостающие таблицы вы создадите позднее. Укажите, как они будут называться.
3.  На основе списка таблиц в DDS составьте список сущностей и полей, которые необходимо загрузить из API. Использовать все методы API необязательно: важно загрузить ту информацию, которая нужна для выполнения задачи.

📌 В следующих шагах спроектируйте структуру таблиц для трёх слоёв, заведённых в вашем хранилище. Сделайте это в обратном порядке — сначала итоговую витрину и только в конце слой сырых данных.

**2.1. Задайте структуру витрины расчётов с курьерами**

На основе изученных данных и вводных о составе витрины составьте DDL-запрос для создания витрины. Назовите её `cdm.dm_courier_ledger`.

В качестве результата проектирования оформите DDL-запрос для создания витрины. Назовите витрину `cdm.dm_courier_ledger`.

**2.2. Спроектируйте структуру DDS-слоя**

В детальном слое необходимо разложить данные из подсистемы доставки по модели «снежинка». Составьте список таблиц, которые необходимо добавить в хранилище, а также спроектируйте структуру этих таблиц.

Вам нужно не только создать новые таблицы, но и изменить уже существующие. Например, в сущность «Заказ» добавится ссылка на сущность «Курьер».

Составьте DDL-скрипт для формирования новой структуры DDS-слоя.

**2.3. Спроектируйте структуру STG-слоя**

STG-слой отражает сырые данные, полученные вами из API подсистемы доставки.

Данные в этом слое должны быть такими же, как и данные, которые приходят из API. Вы получите JSON, поэтому в БД тоже должен будет лежать JSON.

Из JSON важно получить ключевые поля, которые идентифицируют объект, лежащий в базе, — идентификаторы. Полезно также вытаскивать технические поля — время создания или обновления сущности, время загрузки.

**2.4. Выполните составленные ранее DDL-скрипты**

Теперь пришло время применить составленные DDL-скрипты в вашем хранилище. Выполните скрипты, составленные вами ранее: задайте таблицы в хранилище.

### 3. Реализуйте DAG

Следующим шагом реализуйте ДАГи, которые наполнят все слои хранилища данными.

**3.1. Реализуйте заполнение STG-слоя**

Создайте DAG, который будет заполнять таблицы staging-слоя данными из API.

Данных много, а API отдаёт информацию порционно. Чтобы выгрузить все данные из API, понадобится постраничное чтение (англ. paging). Чтобы организовать постраничное чтение, используйте поля `sort_field`, `sort_direction`, `offset`, `limit`.

Вы можете загрузить только `limit` записей за одно обращение к API. Допустим, `limit=50`:

1.  При первом обращении вы указываете `limit=50`, `offset=0`.
2.  При втором обращении — `limit=50`, `offset=50`, поскольку первые 50 записей уже загружены и их можно пропустить.
3.  При третьем обращении — `limit=50`, `offset=100` и т. д.

Как гарантировать, что вы не пропустите данные? Используйте сортировку — `sort_field` и `sort_direction`. Если указывать сортировку, то пропущенными (через `offset`) окажутся именно те записи, которые вы загрузили в предыдущую итерацию. Без сортировки в `offset` могут попасть произвольные записи, в том числе и те, которые вы ещё не загружали.

Загрузите данные за 7 предыдущих дней.

**3.2. Реализуйте заполнение DDS-слоя**

Дополните DAG, чтобы заполнять таблицы DDS-слоя данными из STG-слоя.

Создайте новый DAG для наполнения измерений, а чтобы заполнить таблицы фактов, доработайте DAG, созданный в спринте. Так вам не надо будет задумываться о том, какой DAG выполняется раньше, а какой позднее и каким образом объединять информацию из двух мест.

Таким же подходом можно воспользоваться при наполнении изменённых таблиц. Например, таблицы заказов.

**3.3. Реализуйте заполнение CDM-слоя**

Дополните DAG ещё раз, чтобы заполнять витрины.

📌 Данные обновляются постоянно. Ваши DAG должны работать не один раз, а каждый день, пока вы не закончите проходить спринт.

